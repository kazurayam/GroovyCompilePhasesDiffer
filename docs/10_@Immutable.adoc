== How Groovy Compiler processes the @Immutable annotation

One day, I wanted to learn something about Abstract Syntax Tree Transformation performed by Groovy Compiler. I read a book link:https://livebook.manning.com/book/groovy-in-action-second-edition/chapter-9#96[Groovy in Action, Second edition, Chapter 9, Compile-time metaprogramming and AST transformations]

=== Sample class with `@Immutable` annotation

The book presented a sample Groovy class `Genius` with `@Immutable` annotation.

[source,groovy]
----
include::../app/src/main/groovy/org/example/Genius.groovy[]
----

=== JUnit5 test for the `Genius` class

[source,groovy]
----
include::../app/src/test/groovy/org/example/GeniusTest.groovy[]
----

The tests passed. The tests proved that:

1. `@Immutable` annotation resulted a Map constructor for the `Genuin` class; like `new Geniums(firstName:'Albert',lastName:'Einstein')`
2. `@Immutable` annotation resulted a Tuple-style constructor; like `new Genius('Albert','Einsten')`
3. `@Immutable` annotation resulted `boolean equals(Genius a, Genius b)` method
4. `@Immutable` annotation resulted Getter methods, like `instance.getFirstName()`
5. `@Immutable` annotation resulted `toString` method, like `instance.toString()`

I could examine the description in the book is right. No surprise. But I was not fully convinced. The book talked much about *Abstract Syntax Tree*. Groovy Compiler parses a *.groovy file into an AST object; transforms the AST object into another phase of AST until it ends up with a `.class` file. I wanted to see how the AST objects of every compile phases look like.

So, I wanted to *unparse* the AST objects into a human-readable source code in Groovy which explicitly declares all the methods and properties in the AST.

But, how can I *unparse* the AST object into a human-readable text?
